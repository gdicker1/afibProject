''' multiFigMake.py
Creates gifs and graphs of data generated by heter_runner.py and homg_runner.py
 as well as student-t test analysis of
    1) Ha: tissue ablation concentration < Patch concentration
    2) Ha: tissue ablation concentration < Patch concentration tval
    3) Ha: time to terminate for boundary connected tissues < Unconnected
For UWyo Ind. Study in Genetic Algorithms Spring 2018
'''

import argparse
import os
from subprocess import run
import numpy as np
from numpy.random import random_integers
from scipy.stats.mstats import ttest_ind
from matplotlib import cm
from matplotlib import pyplot as plt

from CMAES_xmlMake import runtimeToVM_AblnOnly, getRuntimes
from createAblation import createAblationFile, createDisconnAblnFile

bestAblnC = np.array((255, 0, 0)) / 255  # Red
ablnBarC = np.array((255, 0, 0, 127)) / 255  # Half apha value for bars
bestQuarsC = np.array((132, 50, 132)) / 255   # Dark purple
quarBarC = np.array((132, 50, 132, 127)) / 255
bestConnsC = np.array((70, 190, 70)) / 255  # Green
connBarC = np.array((70, 190, 70, 127)) / 255
bestFitsC = np.array((0, 0, 255)) / 255  # Blue
fitBarC = np.array((0, 0, 255, 127)) / 255
bestLAC = np.array((255, 165, 0)) / 255  # Orange
LAbarC = np.array((255, 165, 0, 127)) / 255
barColor = np.array((255, 0, 255, 127)) / 255  # Pinkish purple


def createGif(apFiles, gifDir, gifName):
    tempDir = os.path.join(gifDir, 'temp')
    for i in range(len(apFiles)):
        file = apFiles[i]
        if(os.path.isfile(file)):
            gifAdd = ''
            splitFile = file.split('/')
            if('initial' in splitFile):
                gifAdd = 'init'
            elif('midPoint' in splitFile):
                gifAdd = 'mid'
            elif('final' in splitFile):
                gifAdd = 'terminal'
            else:
                break
            gifFile = os.path.join(gifDir, gifName + gifAdd + '.gif')
            run(['mkdir', '-p', tempDir])
            dataSet = np.loadtxt(file, delimiter=',')
            ablnMatrix = np.copy(dataSet[0])  # Can cheat to get abln matrix
            for stepNum, sett in enumerate(dataSet[1:]):
                dataMatrix = np.copy(sett)
                for j in range(len(dataMatrix)):
                    if ablnMatrix[j] == 0:
                        dataMatrix[j] = np.nan
                dataMatrix = dataMatrix.reshape(80, 80).T

                tempFig, tempAx = plt.subplots(1, 1)
                current_cmap = cm.get_cmap('Greys')
                current_cmap = current_cmap.set_bad(bestAblnC)
                plt.title(gifName + ' ' + gifAdd + '_Frame:{:03d}'.format(stepNum))
                plt.xlabel('x')
                plt.ylabel('y')
                tempAx.imshow(dataMatrix, cmap='Greys', vmin=0, vmax=1)
                saveFigFName = splitFile[-1][:-4] + '_{:03d}'.format(stepNum) + '.png'
                saveFigFile = os.path.join(tempDir,
                                           saveFigFName)
                tempFig.savefig(saveFigFile, format='png', bbox_inches='tight')
                plt.close()
            picFiles = os.path.join(tempDir, '*.png')
            runCommand = 'convert -coalesce -layers OptimizePlus -resize 200x200 -quality 50% -delay 5 -loop 0 {} {}'
            rC = runCommand.format(picFiles, gifFile)
            run(rC, shell=True)
            run('rm -r ' + tempDir, shell=True)
        else:
            continue

    return


if __name__ == '__main__':
    parser = argparse.ArgumentParser()
    parser.add_argument('dataPath',
                        help='Absolute path to the file containing SetX',
                        type=str)
    parser.add_argument('resultPath',
                        help='Absolute path to save resulting files to',
                        type=str)
    parser.add_argument('tissuePath',
                        help='Absolute path to the reference tissue',
                        type=str)
    parser.add_argument('batchPath',
                        help='Absolute path to the batchtool',
                        type=str)
    parser.add_argument('setStartInd',
                        help='Starting index of SetX to analyze',
                        type=int)
    parser.add_argument('setStopInd',
                        help='Ending index of SetX to analyze',
                        type=int)
    parser.add_argument('--gif', action='store_true', default=False,
                        help='Indicate whether to make gifs from ApTimeFlag data')
    parser.add_argument('--bndTest', action='store_true', default=False,
                        help='Indicate whether to test if boundary connection matters')
    parser.add_argument('--het', action='store_true', default=False,
                        help='Indicate whether data is for tissue with (use het) or without a patch')
    argDict = vars(parser.parse_args())
    dataPath = argDict['dataPath']
    resDir = argDict['resultPath']
    tissueDir = argDict['tissuePath']
    batchDir = argDict['batchPath']
    startInd = argDict['setStartInd']
    stopInd = argDict['setStopInd']
    makeGif = argDict['gif']
    patchPresent = argDict['het']
    boundaryTest = argDict['bndTest']

    resDir = os.path.join(resDir, dataPath.split('/')[-2])

    print('\ndataPath:', dataPath)
    print('resDir:', resDir)
    print('tissueDir:', tissueDir)
    print('batchDir:', batchDir)
    print('startInd:', startInd)
    print('stopInd:', stopInd)
    print('\n')

    imageDir = os.path.join(resDir, 'Images')
    gifDir = os.path.join(resDir, 'Gifs')
    tempDir = os.path.join(resDir, 'temp')

    if(not os.path.exists(dataPath)):
        raise Exception('dataPath does not exist')
    if(not os.path.exists(tissueDir)):
        raise Exception('tissueDir does not exist')
    if(not os.path.exists(batchDir)):
        raise Exception('batchDir does not exist')
    if(not os.path.exists(resDir)):
        run(['mkdir', '-p', resDir])
    if(not os.path.exists(imageDir)):
        run(['mkdir', '-p', imageDir])
    if(not os.path.exists(gifDir)):
        run(['mkdir', '-p', gifDir])
    if(not os.path.exists(tempDir)):
        run(['mkdir', '-p', tempDir])

    batchPath = os.path.join(batchDir, 'VisibleEP_BatchTool_1')

    # Arrays to store information over the multiple sets
    ## For fitnesses
    bestFitnesses = np.empty((200, stopInd - startInd + 1))
    avgFitnesses = np.empty((200, stopInd - startInd + 1))
    ## For ablations
    bestAblns = np.empty((200, stopInd - startInd + 1))
    avgAblns = np.empty((200, stopInd - startInd + 1))
    ## For number quarantined
    bestQuaras = np.empty((200, stopInd - startInd + 1))
    avgQuaras = np.empty((200, stopInd - startInd + 1))
    ## For number connected
    bestConnes = np.empty((200, stopInd - startInd + 1))
    avgConnes = np.empty((200, stopInd - startInd + 1))
    ## For L/A ratios
    bestLAs = np.empty((200, stopInd - startInd + 1))
    avgLAs = np.empty((200, stopInd - startInd + 1))
    ## For the best ablation pattern for the sets
    bestSolutions = np.empty((24, stopInd - startInd + 1))
    ## For the position of tissue patches
    patchPoses = np.empty(stopInd - startInd + 1)

    print('Creating images and gifs from the data')
    for i in range(startInd, stopInd + 1):
        # To find the solutions.csv file
        setDirName = 'set' + str(i)
        setPath = os.path.join(dataPath, setDirName)
        solFile = os.path.join(setPath, 'Text_Files', 'solutions.csv')

        # If tissue with patch, find patch startPos
        if patchPresent:
            stdOutFile = os.path.join(setPath, 'afibHet{}_stdout'.format(i))
            patchLine = 'blergh'
            with open(stdOutFile, 'r') as studFile:
                lineArr = studFile.readlines()
                patchLine = lineArr[10]
            patchPos = int(patchLine[-4:-2])
            patchPoses[i] = patchPos

        # Choose a random ApTimeFlag matrix to turn into a gif
        apDir = os.path.join(setPath, 'Text_Files', 'APTimes')
        apInitFName = 'apTime_' + str(0) + '_' \
                      + str(random_integers(0, 9)) + '.csv'
        apInitFile = os.path.join(apDir, 'initial', apInitFName)
        apMidFName = 'apTime_' + str(0) + '_' \
                     + str(random_integers(0, 9)) + '.csv'
        apMidFile = os.path.join(apDir, 'midPoint', apMidFName)
        apFinalFName = 'apTime_' + str(0) + '_' \
                       + str(random_integers(0, 9)) + '.csv'
        apFinalFile = os.path.join(apDir, 'final', apFinalFName)

        # Create a gif of the apFiles
        if makeGif:
            createGif([apInitFile, apMidFile, apFinalFile],
                      gifDir, 'set{}'.format(i))
            print('\tGif for set{} made'.format(i))

        # Slice data from the solution file
        data = np.loadtxt(solFile, delimiter=',', skiprows=1)

        iterations = data.T[0].reshape(-1, 15).T[0]
        ablns = data.T[1].T.reshape(-1, 15) / 6400
        quars = data.T[2].T.reshape(-1, 15) / 6400
        conns = data.T[3].T.reshape(-1, 15) / 6400
        las = (((80 * 80) * conns + 4 * 80) /
               ((80 * 80) * (1 - ablns - quars)))
        fits = data.T[4].T.reshape(-1, 15)
        bestSol = data[-15][-24:]  # Best abln pattern from final gen

        padLength = 200 - fits.shape[0]
        bestAbls = ablns.T[0]
        bestAblns.T[i] = np.pad(bestAbls, (0, padLength), 'edge')
        avgAbls = np.average(ablns, axis=1)
        avgAblns.T[i] = np.pad(avgAbls, (0, padLength), 'edge')
        errorAbls = np.std(ablns, axis=1) / ablns.shape[1]

        bestQuars = quars.T[0].T
        bestQuaras.T[i] = np.pad(bestQuars, (0, padLength), 'edge')
        avgQuars = np.average(quars, axis=1)
        avgQuaras.T[i] = np.pad(avgQuars, (0, padLength), 'edge')
        errorQuars = np.std(quars, axis=1) / quars.shape[1]

        bestConns = conns.T[0]
        bestConnes.T[i] = np.pad(bestConns, (0, padLength), 'edge')
        avgConns = np.average(conns, axis=1)
        avgConnes.T[i] = np.pad(avgConns, (0, padLength), 'edge')
        errorConns = np.std(conns, axis=1) / conns.shape[1]

        bestLA = las.T[0]
        bestLAs.T[i] = np.pad(bestLA, (0, padLength), 'edge')
        avgLA = np.average(las, axis=1)
        avgLAs.T[i] = np.pad(avgLA, (0, padLength), 'edge')
        errorLA = np.std(las, axis=1) / las.shape[1]

        bestFits = fits.T[0].T
        bestFitnesses.T[i] = np.pad(bestFits, (0, padLength), 'edge')
        avgFits = np.average(fits, axis=1)
        avgFitnesses.T[i] = np.pad(avgFits, (0, padLength), 'edge')
        errorFits = np.std(fits, axis=1) / fits.shape[1]

        bestSolutions.T[i] = bestSol

        # Creating a figure summary of best tissue parameters for this set
        summaryFig, summAx = plt.subplots(1, 1)
        summAx.plot(iterations, bestAbls, linestyle='-',
                    color=bestAblnC, label='Best Ablated')
        summAx.plot(iterations, bestQuars, linestyle='-',
                    color=bestQuarsC, label='Best Quarantined')
        summAx.plot(iterations, bestConns, linestyle='-',
                    color=bestConnsC, label='Best Connected')
        summAx.plot(iterations, bestFits, linestyle='-',
                    color=bestFitsC, label='Best Fitness')
        summAx.plot(iterations, bestLA, linestyle='-',
                    color=bestLAC, label='Best Length/Area ratio')
        plt.title(setDirName + ' Summary')
        plt.xlabel('Epochs')
        plt.ylabel('Proportion')
        plt.legend()
        summaryFigFile = os.path.join(imageDir,
                                      'set{}_summary.png'.format(i))
        summaryFig.savefig(summaryFigFile, format='png', bbox_inches='tight')
        plt.close()

        # Creating figure summmary of average tissue parameters for this set
        tissuePropFig, tissueAx = plt.subplots(1, 1)
        tissueAx.errorbar(iterations, avgAbls, yerr=errorAbls,
                          ecolor=ablnBarC, capsize=2.5, linestyle='--',
                          color=bestAblnC, label='Average Ablated')
        tissueAx.errorbar(iterations, bestQuars, yerr=errorQuars,
                          ecolor=quarBarC, capsize=2.5, linestyle='--',
                          color=bestQuarsC, label='Average Quarantined')
        tissueAx.errorbar(iterations, avgConns, yerr=errorConns,
                          ecolor=connBarC, capsize=2.5, linestyle='--',
                          color=bestConnsC, label='Average Connected')
        tissueAx.errorbar(iterations, avgLA, yerr=errorLA,
                          ecolor=LAbarC, capsize=2.5, linestyle='--',
                          color=bestLAC, label='Length/Area ratio')
        plt.title(setDirName + ' Average Tissue Properties')
        plt.xlabel('Epochs')
        plt.ylabel('Proportion of 6400 cells')
        plt.legend()
        propFigFile = os.path.join(imageDir,
                                   'set{}_tissueProp.png'.format(i))
        tissuePropFig.savefig(propFigFile, format='png', bbox_inches='tight')
        plt.close()

        # Creating the summary fitness plot of this set
        fitnessFig, fitAx = plt.subplots(1, 1)
        fitAx.plot(iterations, bestFits, linestyle='-',
                   color=bestFitsC, label='Best Fitness')
        fitAx.errorbar(iterations, avgFits, yerr=errorFits,
                       ecolor=fitBarC, capsize=2.5, linestyle='--',
                       color=bestFitsC, label='Average Fitness')
        plt.title(setDirName + ' Fitness')
        plt.xlabel('Epochs')
        plt.ylabel('Proprotion of 1500 ms')
        plt.legend()
        fitFigFile = os.path.join(imageDir,
                                  'set{}_fits.png'.format(i))
        fitnessFig.savefig(fitFigFile, format='png', bbox_inches='tight')
        plt.close()
        print('\tImages made for set{}'.format(i))

    # Getting summary stats of the best and average fitnesses
    bestFitsAve = np.average(bestFitnesses, axis=1)
    bestFitsErr = np.std(bestFitnesses, axis=1) / bestFitnesses.shape[1]
    avgFitsAve = np.average(avgFitnesses, axis=1)
    avgFitsErr = np.std(avgFitnesses, axis=1) / avgFitnesses.shape[1]

    # Summary stats of the tissue props
    bestAblsAve = np.average(bestAblns, axis=1)
    bestAblsErr = np.average(bestAblns, axis=1) / bestAblns.shape[1]
    avgAblsAve = np.average(avgAblns, axis=1)
    avgAblsErr = np.average(avgAblns, axis=1) / avgAblns.shape[1]

    bestQuarasAve = np.average(bestQuaras, axis=1)
    bestQuarasErr = np.average(bestQuaras, axis=1) / bestQuaras.shape[1]
    avgQuarasAve = np.average(avgQuaras, axis=1)
    avgQuarasErr = np.average(avgQuaras, axis=1) / avgQuaras.shape[1]

    bestConnesAve = np.average(bestConnes, axis=1)
    bestConnesErr = np.average(bestConnes, axis=1) / bestConnes.shape[1]
    avgConnesAve = np.average(avgConnes, axis=1)
    avgConnesErr = np.average(avgConnes, axis=1) / avgConnes.shape[1]

    bestLAsAve = np.average(bestLAs, axis=1)
    bestLAsErr = np.average(bestLAs, axis=1) / bestLAs.shape[1]
    avgLAsAve = np.average(avgLAs, axis=1)
    avgLAsErr = np.average(avgLAs, axis=1) / avgLAs.shape[1]

    # Plotting the summary stats of the best and avg fits
    fitSummary, ax = plt.subplots(1, 1)
    epochs = np.arange(bestFitnesses.shape[0]) * 10
    ax.errorbar(epochs, bestFitsAve, yerr=bestFitsErr,
                ecolor=fitBarC, capsize=2.5, linestyle='-',
                color=bestFitsC, label='Best Fitness')
    ax.errorbar(epochs, avgFitsAve, yerr=bestFitsErr,
                ecolor=fitBarC, capsize=2.5, linestyle='--',
                color=bestFitsC, label='Average Fitness')
    plt.title('Fitness Summary of All Runs')
    plt.xlabel('Epochs')
    plt.ylabel('Proprotion of 10000 ms')
    plt.legend()
    fitSummFile = os.path.join(resDir, 'fitnessSummary.png')
    fitSummary.savefig(fitSummFile, format='png', bbox_inches='tight')
    plt.close()

    # Plotting the summary tissue props for best solutions
    bestTissueSummary, ax = plt.subplots(1, 1)
    epochs = np.arange(bestLAs.shape[0]) * 10
    ax.errorbar(epochs, bestAblsAve, yerr=bestAblsErr,
                ecolor=ablnBarC, capsize=2.5, linestyle='-',
                color=bestAblnC, label='Best %Ablated')
    ax.errorbar(epochs, bestQuarasAve, yerr=bestQuarasErr,
                ecolor=quarBarC, capsize=2.5, linestyle='-',
                color=bestQuarsC, label='Best %Quarantined')
    ax.errorbar(epochs, bestConnesAve, yerr=bestConnesErr,
                ecolor=connBarC, capsize=2.5, linestyle='-',
                color=bestConnsC, label='Best %Connected')
    ax.errorbar(epochs, bestLAsAve, yerr=bestLAsErr,
                ecolor=LAbarC, capsize=2.5, linestyle='-',
                color=bestLAC, label='Best L/A ratio')
    plt.title('Tissue Summary of All Runs for Best Solutions')
    plt.xlabel('Epochs')
    plt.ylabel('Proprotion')
    plt.legend()
    tissueSummBestFile = os.path.join(resDir, 'tissuePropSummaryBest.png')
    bestTissueSummary.savefig(tissueSummBestFile, format='png', bbox_inches='tight')
    plt.close()

    # Plotting the summary tissue props averaged over solutions
    avgTissueSummary, ax = plt.subplots(1, 1)
    epochs = np.arange(avgLAs.shape[0]) * 10
    ax.errorbar(epochs, avgAblsAve, yerr=avgAblsErr,
                ecolor=ablnBarC, capsize=2.5, linestyle='--',
                color=bestAblnC, label='Average %Ablated')
    ax.errorbar(epochs, avgQuarasAve, yerr=avgQuarasErr,
                ecolor=quarBarC, capsize=2.5, linestyle='--',
                color=bestQuarsC, label='Average %Quarantined')
    ax.errorbar(epochs, avgConnesAve, yerr=avgConnesErr,
                ecolor=connBarC, capsize=2.5, linestyle='--',
                color=bestConnsC, label='Average %Connected')
    ax.errorbar(epochs, avgLAsAve, yerr=avgLAsErr,
                ecolor=LAbarC, capsize=2.5, linestyle='--',
                color=bestLAC, label='Average L/A ratio')
    plt.title('Tissue Summary of All Runs Averaged over All Solutions')
    plt.xlabel('Epochs')
    plt.ylabel('Proprotion')
    plt.legend()
    tissueSummAveFile = os.path.join(resDir, 'tissuePropSummaryAve.png')
    avgTissueSummary.savefig(tissueSummAveFile, format='png', bbox_inches='tight')
    plt.close()


    print('\tAll figures made for all sets')
    # End reading data & creating graphs

    # If heterogeneous tissue, test amount of ablation in patch regions
    if patchPresent:
        print('\nTesting if there is a higher concentration of ablated cells in patch')
        testDir = os.path.join(tempDir, 'PatchConcentrationTest')
        ablnFile = os.path.join(testDir, 'abln.txt')
        testLogFile = os.path.join(testDir, 'patchConcentrationTestResults.csv')
        testStatFile = os.path.join(testDir, 'patchConcentrationStats.csv')

        patchWidth = 20

        patchConces = np.empty(stopInd - startInd + 1)
        tissueConces = np.empty(stopInd - startInd + 1)
        if(not os.path.exists(testDir)):
            run(['mkdir', '-p', testDir])
        for i in range(stopInd - startInd + 1):
            patchPos = int(patchPoses[i])
            patchEnd = int(patchPos + patchWidth)
            sol = bestSolutions.T[i]

            createAblationFile(sol, ablnFile)
            tissueMat = np.loadtxt(ablnFile).reshape(80, 80)
            patchMat = tissueMat[patchPos:patchEnd, patchPos:patchEnd]
            patchConcentration = np.sum(patchMat) / (patchWidth * patchWidth)
            tissueConcentration = np.sum(tissueMat) / (80 * 80)
            patchConces[i] = patchConcentration
            tissueConces[i] = tissueConcentration

        with open(testLogFile, 'w') as testLog:
            testLog.write('patch ablated/area,\ttissue ablated/area\n')
            theString = '{},\t{}\n'
            for i in range(len(patchConces)):
                testLog.write(theString.format(patchConces[i], tissueConces[i]))

        # Finding the test statistics
        with open(testStatFile, 'w') as statLog:
            tval, pval = ttest_ind(patchConces, tissueConces)
            statLog.write('Testing Ha: tissue ablation concentration < Patch concentration')
            statLog.write('Raw tval: {}\tRaw pval: {}\n'.format(tval, pval))
            print('Raw tval: {}\tRaw pval: {}\n'.format(tval, pval))
            actualPval = pval / 2
            print('Ha: tissue ablation concentration < Patch concentration tval:{}\tpval:{}'.format(tval, actualPval))
            statLog.write('Raw_tval: {}\t1-tail_pval:{}'.format(tval, actualPval))
        print('\tTesting & logging complete')

    if boundaryTest:
        # Test boundary area connection importance
        print('\nTesting if boundary connection matters')
        ## First create 10 tissues never seen before
        testDir = os.path.join(tempDir, 'BoundaryConnTest')
        if(not os.path.exists(testDir)):
            run(['mkdir', testDir])
        testInfoFile = os.path.join(resDir, 'connTestResults.csv')
        statTestFile = os.path.join(resDir, 'connTestStatResults.txt')
        emptyAblnF = os.path.join(testDir, 'abln.txt')
        normAblnF = os.path.join(testDir, 'abln_norm.txt')
        disAblnF = os.path.join(testDir, 'abln_dis.txt')
        disSameAblnF = os.path.join(testDir, 'abln_disSame.txt')
        ### Use the prebuilt hom_fileMake.py for this
        run(['python', 'hom_fileMake.py',
             '0', '10', testDir])

        xmlFiles = [os.path.join(testDir, 'paramfile_' + str(i) + '.txt')
                    for i in range(10)]
        logFiles = [os.path.join(testDir, 'consoleLog_' + str(i) + '.txt')
                    for i in range(10)]

        emptyAblnTimes = []
        normAblnTimes = []
        unconnAblnTimes = []
        sameAblnNumTimes = []
        bestSolutions = bestSolutions.T

        print('\tPerforming trials and logging info')
        with open(testInfoFile, 'w') as testLog:

            testLog.write('set, empty, normal, disconnected, same\n')

            for j, sol in enumerate(bestSolutions):
                eTempTimes = [0] * 10
                nTempTimes = [0] * 10
                uTempTimes = [0] * 10
                sTempTimes = [0] * 10

                # write the ablation files
                createAblationFile(sol, normAblnF)
                createDisconnAblnFile(sol, disAblnF, disSameAblnF)

                # run the tests
                for i in range(10):
                    xml = xmlFiles[i]
                    log = logFiles[i]
                    # Test 0: no ablated cells
                    runtimeToVM_AblnOnly(xml, xml, 10000, 'ApTimeFlag', testDir,
                                         0, 0, emptyAblnF)
                    with open(log, 'w') as file:
                        run([batchPath, xml], stdout=file)
                    eTempTimes[i] = getRuntimes(log) / 10000
                    # Test 1: no change to abln file
                    runtimeToVM_AblnOnly(xml, xml, 10000, 'ApTimeFlag', testDir,
                                         0, 0, normAblnF)
                    with open(log, 'w') as file:
                        run([batchPath, xml], stdout=file)
                    nTempTimes[i] = getRuntimes(log) / 10000
                    # Test 2: Remove ablation in edges
                    runtimeToVM_AblnOnly(xml, xml, 10000, 'ApTimeFlag', testDir,
                                         0, 0, disAblnF)
                    with open(log, 'w') as file:
                        run([batchPath, xml], stdout=file)
                    uTempTimes[i] = getRuntimes(log) / 10000
                    # Test 3: Test 2 but with same number of ablations as Test 1
                    runtimeToVM_AblnOnly(xml, xml, 10000, 'ApTimeFlag', testDir,
                                         0, 0, disSameAblnF)
                    with open(log, 'w') as file:
                        run([batchPath, xml], stdout=file)
                    sTempTimes[i] = getRuntimes(log) / 10000
                print('\tTrials for set{} solution finished'.format(j))

                emptyAblnTimes.append(np.sum(eTempTimes) / 10)
                normAblnTimes.append(np.sum(nTempTimes) / 10)
                unconnAblnTimes.append(np.sum(uTempTimes) / 10)
                sameAblnNumTimes.append(np.sum(sTempTimes) / 10)

                testLog.write('{}, {}, {}, {}, {}\n'.format(j,
                                                          emptyAblnTimes[-1],
                                                          normAblnTimes[-1],
                                                          unconnAblnTimes[-1],
                                                          sameAblnNumTimes[-1]))

        # Ha: P1 < P2 implies ttest_ind(P2, P1)
        nVeTval, nVePval = ttest_ind(emptyAblnTimes, normAblnTimes)
        print('\tNorm vs. Empty Stats:', nVeTval, nVePval)
        nVuTval, nVuPval = ttest_ind(unconnAblnTimes, normAblnTimes)
        print('\tNorm vs. Unconnected Stats:', nVuTval, nVuPval)
        nVsTval, nVsPval = ttest_ind(sameAblnNumTimes, normAblnTimes)
        print('\tNorm vs. Same Connected Stats:', nVsTval, nVsPval)
        uVeTval, uVePval = ttest_ind(unconnAblnTimes, emptyAblnTimes)
        print('\tUnconnected vs. Empty Connected Stats:', uVeTval, uVePval)
        uVsTval, uVsPval = ttest_ind(unconnAblnTimes, sameAblnNumTimes)
        print('\tUnconnected vs. Same Connected Stats:', uVsTval, uVsPval)

        print('\tWriting above results to:', statTestFile)
        tempString = '{:30}\ttval:{:10}\tpval:{:10}\n'
        with open(statTestFile, 'w') as statLog:
            statLog.write('Using 2-tailed t-test\n')
            statLog.write(tempString.format('NormAbln_less_EmptyAbln:',
                                            nVeTval, nVePval / 2))
            statLog.write(tempString.format('NormAbln_less_UnconnectedAbln:',
                                            nVuTval, nVuPval / 2))
            statLog.write(tempString.format('NormAbln_less_SameNumAblnUnconn:',
                                            nVsTval, nVsPval / 2))
            statLog.write(tempString.format('UnconnectedAbln_equal_EmptyAbln:',
                                            uVeTval, uVePval))
